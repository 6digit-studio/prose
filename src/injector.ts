import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs';
import { join } from 'path';
import type { ProjectMemory } from './memory.js';

/**
 * Format a project name for display (strip path prefixes)
 */
function formatProjectName(name: string): string {
    return name.replace(/^-Users-[^-]+-src-/, '').replace(/^-/, '');
}

/**
 * Generate usage instructions for agents to use prose
 */
export function generateInstructions(): string {
    return `### ðŸ§  Semantic Memory & Search
This project uses \`prose\` to maintain a cross-session semantic memory of decisions, insights, and story beats.

- **Semantic Search**: If you're unsure about a past decision or need context on a feature, run:
  \`\`\`bash
  prose search "your question or keywords"
  \`\`\`
- **Project Status**: To see a summary of recent sessions and evolved memory, run:
  \`\`\`bash
  prose status
  \`\`\`
- **View Chronicles**: Run \`prose serve\` to browse the interactive development timeline in your browser.
`;
}

/**
 * Ensure a CLAUDE.md.template exists, creating it from CLAUDE.md if necessary
 */
export function ensureTemplate(rootPath: string): void {
    const templatePath = join(rootPath, 'CLAUDE.md.template');
    const targetPath = join(rootPath, 'CLAUDE.md');

    if (existsSync(templatePath)) {
        console.log(`â„¹ï¸  CLAUDE.md.template already exists`);
        return;
    }

    let baseContent = '';
    if (existsSync(targetPath)) {
        baseContent = readFileSync(targetPath, 'utf-8');
    } else {
        baseContent = '# Project Guide\n\nThis is a standard guide for agents.';
    }

    // Check if it already has tags
    if (baseContent.includes('{{PROSE_SUMMARY}}')) {
        console.log(`â„¹ï¸  CLAUDE.md already contains prose tags, using as basis for template`);
    } else {
        baseContent += `\n\n## ðŸ§¬ Project Consciousness\n{{PROSE_SUMMARY}}\n\n### Decisions\n{{PROSE_DECISIONS}}\n\n### Instructions & Usage\n{{PROSE_INSTRUCTIONS}}\n\n### Active Gotchas\n{{PROSE_GOTCHAS}}\n`;
    }

    writeFileSync(templatePath, baseContent);
    console.log(`âœ… Created CLAUDE.md.template from existing CLAUDE.md`);
}

/**
 * Inject project memory into CLAUDE.md if a template exists
 */
export function injectMemory(rootPath: string, memory: ProjectMemory): void {
    const templatePath = join(rootPath, 'CLAUDE.md.template');
    const targetPath = join(rootPath, 'CLAUDE.md');

    if (!existsSync(templatePath)) {
        return;
    }

    try {
        let content = readFileSync(templatePath, 'utf-8');

        // Prepare data
        const summary = memory.current.focus?.current_goal || 'No active focus';

        const decisions = (memory.current.decisions?.decisions || [])
            .map(d => `- **${d.what}**: ${d.why}`)
            .join('\n') || 'None recorded yet.';

        const insights = (memory.current.insights?.insights || [])
            .map(i => `- ${i.learning}`)
            .join('\n') || 'None recorded yet.';

        const gotchas = (memory.current.insights?.gotchas || [])
            .map(g => `- **${g.issue}**: ${g.solution}`)
            .join('\n') || 'None recorded yet.';

        const instructions = generateInstructions();

        // Replace placeholders
        content = content.replace(/{{PROSE_SUMMARY}}/g, summary);
        content = content.replace(/{{PROSE_DECISIONS}}/g, decisions);
        content = content.replace(/{{PROSE_INSIGHTS}}/g, insights);
        content = content.replace(/{{PROSE_GOTCHAS}}/g, gotchas);
        content = content.replace(/{{PROSE_INSTRUCTIONS}}/g, instructions);

        // Add injection notice
        const notice = `\n\n> [!NOTE]\n> This file is automatically generated from \`CLAUDE.md.template\` by \`prose\`.\n> Last updated: ${new Date().toLocaleString()}\n`;

        writeFileSync(targetPath, content + notice);
        console.log(`ðŸ“ Updated CLAUDE.md from template`);
    } catch (error: any) {
        console.error(`âš ï¸  Failed to inject memory into CLAUDE.md: ${error.message}`);
    }
}

/**
 * Generate SKILL.md content from project memory
 * This creates a Claude Code skill that teaches Claude how to use prose for context
 */
export function generateSkillContent(memory: ProjectMemory, projectName: string): string {
    const displayName = formatProjectName(projectName);

    // Build description for semantic matching
    const description = `Project memory and context for ${displayName}. Use when needing past decisions, implementation rationale, project history, or when the user asks "why did we..." or "what was the decision about...".`;

    // Only gotchas - these are landmines worth having upfront
    const gotchas = (memory.current.insights?.gotchas || [])
        .map(g => `- **${g.issue}**: ${g.solution}`)
        .join('\n');

    const gotchasSection = gotchas
        ? `\n## âš ï¸ Active Gotchas\nThese are known landmines - avoid them:\n\n${gotchas}\n`
        : '';

    // Current focus if available
    const focus = memory.current.focus?.current_goal
        ? `**Current focus**: ${memory.current.focus.current_goal}\n`
        : '';

    const lastUpdated = memory.lastUpdated
        ? new Date(memory.lastUpdated).toLocaleString()
        : 'Never';

    return `---
name: flash
description: ${description}
---

# ${displayName} - Project Memory

This project uses \`prose\` for semantic memory across sessions.
${focus}
## Finding Project Context

Use \`prose search\` to find decisions, insights, and history:

\`\`\`bash
# Search for past decisions
prose search "why did we use X"

# Find implementation rationale
prose search "how does Y work"

# Look up gotchas
prose search "problems with Z"
\`\`\`

## Other Commands

\`\`\`bash
prose show          # View current memory state
prose status        # See memory statistics
prose evolve        # Process new sessions
\`\`\`
${gotchasSection}
---
*Last updated: ${lastUpdated}*
`;
}

/**
 * Write or update the flash skill file
 */
export function writeSkillFile(rootPath: string, memory: ProjectMemory, projectName: string): void {
    const skillsDir = join(rootPath, '.claude', 'skills', 'flash');
    const skillPath = join(skillsDir, 'SKILL.md');

    // Ensure directory exists
    if (!existsSync(skillsDir)) {
        mkdirSync(skillsDir, { recursive: true });
    }

    const content = generateSkillContent(memory, projectName);
    writeFileSync(skillPath, content);
    console.log(`ðŸ“ Updated .claude/skills/flash/SKILL.md`);
}

/**
 * Create initial skill file structure (for prose init)
 */
export function initSkillFile(rootPath: string, projectName: string): void {
    const skillsDir = join(rootPath, '.claude', 'skills', 'flash');
    const skillPath = join(skillsDir, 'SKILL.md');

    // Idempotent: don't overwrite if it exists
    if (existsSync(skillPath)) {
        console.log(`â„¹ï¸  .claude/skills/flash/SKILL.md already exists`);
        return;
    }

    // Ensure directory exists
    if (!existsSync(skillsDir)) {
        mkdirSync(skillsDir, { recursive: true });
    }

    const displayName = formatProjectName(projectName);

    // Create a placeholder skill that will be populated on first evolve
    const placeholder = `---
name: flash
description: Project memory and architectural context for ${displayName}. Use when discussing past decisions, implementation rationale, or project history.
---

# ${displayName} - Project Memory

> This skill will be populated when you run \`prose evolve\`.

## Getting Started

Run these commands to build your project memory:

\`\`\`bash
# Process sessions and evolve memory
prose evolve

# Search through memory
prose search "your query"

# See memory status
prose status
\`\`\`

---

*Generated by [prose](https://github.com/6digit/prose) - Semantic memory for AI development*
`;

    writeFileSync(skillPath, placeholder);
    console.log(`âœ… Created .claude/skills/flash/SKILL.md`);
}

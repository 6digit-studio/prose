#!/usr/bin/env node
/**
 * Claude Prose CLI - Semantic memory for AI development sessions
 *
 * Commands:
 *   evolve   - Process sessions and evolve fragments
 *   search   - Semantic search through memory (alias: grep)
 *   status   - Show memory statistics
 *   show     - Display current fragments for a project
 */

// Load .env file if present (check multiple locations)
import { config } from 'dotenv';
import { homedir } from 'os';
import { join } from 'path';
import { existsSync, mkdirSync, writeFileSync } from 'fs';
config({ quiet: true });  // Load from current directory
config({ path: join(homedir(), '.config', 'claude-prose', '.env'), quiet: true });  // Global config

import { Command } from 'commander';
import { discoverSessionFiles, parseSessionFile, getSessionStats } from './session-parser.js';
import { evolveAllFragments } from './evolve.js';
import { emptyFragments } from './schemas.js';
import {
  loadMemoryIndex,
  saveMemoryIndex,
  loadProjectMemory,
  saveProjectMemory,
  createProjectMemory,
  updateProjectMemory,
  updateCurrentFragments,
  sessionNeedsProcessing,
  getSessionProcessingState,
  searchMemory,
  getMemoryStats,
  getMemoryDir,
  generateContextMarkdown,
  writeContextFile,
} from './memory.js';
import { evolveHorizontal } from './horizontal.js';
import { generateWebsite } from './web.js';

const program = new Command();

program
  .name('claude-prose')
  .description('Semantic memory for AI development sessions - extract, evolve, and query the meaning of your collaboration')
  .version('0.1.0');

// ============================================================================
// init - Set up claude-prose in a project
// ============================================================================

program
  .command('init')
  .description('Initialize claude-prose in the current project')
  .argument('[subcommand]', 'Subcommand: "hooks" to install PreCompact hook')
  .action((subcommand) => {
    const cwd = process.cwd();
    const projectName = cwd.split('/').pop() || 'project';

    if (subcommand === 'hooks') {
      // Install PreCompact hook
      console.log(`üîß Installing PreCompact hook for: ${projectName}\n`);

      const claudeDir = '.claude';
      const settingsPath = `${claudeDir}/settings.local.json`;

      // Check if settings.local.json already exists
      if (existsSync(settingsPath)) {
        console.log(`‚ö†Ô∏è  ${settingsPath} already exists.`);
        console.log('');
        console.log('To add the hook manually, add this to your settings.local.json:');
        console.log('');
        console.log(`  "hooks": {
    "PreCompact": [
      {
        "matcher": "manual",
        "hooks": [
          {
            "type": "command",
            "command": "claude-prose evolve &",
            "timeout": 10
          }
        ]
      }
    ]
  }`);
        return;
      }

      // Create .claude directory if needed
      if (!existsSync(claudeDir)) {
        mkdirSync(claudeDir, { recursive: true });
      }

      // Create settings.local.json with PreCompact hook
      const settings = {
        hooks: {
          PreCompact: [
            {
              matcher: 'manual',
              hooks: [
                {
                  type: 'command',
                  command: 'claude-prose evolve &',
                  timeout: 10,
                },
              ],
            },
          ],
        },
      };

      writeFileSync(settingsPath, JSON.stringify(settings, null, 2));

      console.log(`‚úÖ Created ${settingsPath}`);
      console.log('');
      console.log('Now when you run /compact in Claude Code, claude-prose will');
      console.log('automatically evolve your session memory in the background.');
      console.log('');
      console.log('üí° Note: settings.local.json is gitignored - each developer opts in individually.');
      return;
    }

    // Default init behavior
    console.log(`üß† Initializing claude-prose for: ${projectName}\n`);

    // Create .claude/commands directory
    const commandsDir = '.claude/commands';
    if (!existsSync(commandsDir)) {
      mkdirSync(commandsDir, { recursive: true });
    }

    // Create the flash slash command with instructions
    const flashCommand = `# Project Memory

> This file is generated by \`claude-prose\`. Run \`claude-prose evolve\` to update.

## Quick Start

\`\`\`bash
# Process recent sessions and update memory
claude-prose evolve

# Install PreCompact hook (auto-evolve on /compact)
claude-prose init hooks

# View memory in browser
claude-prose web --open

# Search memory
claude-prose search "why did we decide..."
\`\`\`

## Current Status

No memory evolved yet. Run \`claude-prose evolve\` to process your sessions.

---

*Generated by [claude-prose](https://github.com/anthropics/claude-code) - Semantic memory for AI development sessions*
`;

    writeFileSync(`${commandsDir}/flash.md`, flashCommand);

    console.log('‚úÖ Created .claude/commands/flash.md');
    console.log('');
    console.log('üìù Next steps:');
    console.log('   1. Run: claude-prose evolve');
    console.log('   2. Run: claude-prose init hooks  (optional: auto-evolve on /compact)');
    console.log('   3. Use /flash in Claude Code to see project context');
    console.log('');
    console.log('üí° Tip: Run evolve periodically to keep memory fresh.');
  });

// ============================================================================
// evolve - Process sessions and evolve fragments
// ============================================================================

program
  .command('evolve')
  .description('Process Claude Code sessions and evolve semantic fragments')
  .option('-p, --project <path>', 'Filter to specific project path')
  .option('-l, --limit <n>', 'Limit number of sessions to process', '10')
  .option('-f, --force', 'Reprocess already-processed sessions')
  .option('--dry-run', 'Show what would be processed without making changes')
  .option('-v, --verbose', 'Show detailed progress')
  .action(async (options) => {
    const apiKey = process.env.LLM_API_KEY || process.env.OPENROUTER_API_KEY || process.env.OPENAI_API_KEY;
    if (!apiKey) {
      console.error('‚ùå No API key found. Set LLM_API_KEY, OPENROUTER_API_KEY, or OPENAI_API_KEY in .env or environment');
      process.exit(1);
    }

    console.log('üß¨ Claude Prose - Evolving semantic memory\n');

    // Auto-detect project from current directory if not specified
    let projectFilter = options.project;
    if (!projectFilter) {
      const cwd = process.cwd();
      const cwdSanitized = cwd.replace(/\//g, '-').replace(/^-/, '');
      const index = loadMemoryIndex();
      const matchingProject = Object.keys(index.projects).find(p =>
        p === cwdSanitized || p.endsWith(cwdSanitized) || cwdSanitized.endsWith(p.replace(/^-/, ''))
      );
      if (matchingProject) {
        projectFilter = matchingProject;
        console.log(`üìÅ Evolving: ${matchingProject.replace(/^-Users-[^-]+-src-/, '')}\n`);
      }
    }

    // Discover sessions
    const sessions = discoverSessionFiles(projectFilter);
    const limit = parseInt(options.limit, 10);

    // Load memory index
    const index = loadMemoryIndex();

    // First pass: find sessions that need processing (including active ones with new messages)
    const sessionsNeedingWork: typeof sessions = [];
    for (const session of sessions) {
      // Load or create project memory for this check
      let memory = loadProjectMemory(session.project);
      const conversation = parseSessionFile(session.path);

      // Skip empty sessions entirely
      if (conversation.messages.length === 0) {
        continue;
      }

      if (options.force || sessionNeedsProcessing(
        memory,
        session.sessionId,
        conversation.messages.length,
        session.modifiedTime
      )) {
        sessionsNeedingWork.push(session);
      }
    }

    // Sort oldest-first for temporal evolution, then apply limit
    const sessionsOldestFirst = [...sessionsNeedingWork].sort((a, b) =>
      a.modifiedTime.getTime() - b.modifiedTime.getTime()
    );
    const sessionsToProcess = sessionsOldestFirst.slice(0, limit);

    if (options.verbose) {
      console.log(`üìÅ Found ${sessions.length} sessions, ${sessionsNeedingWork.length} need work, processing ${sessionsToProcess.length}`);
    }

    let processed = 0;
    let totalTokens = 0;

    for (const session of sessionsToProcess) {
      const projectName = session.project;

      // Load or create project memory
      let memory = loadProjectMemory(projectName) || createProjectMemory(projectName);

      // Parse session
      const conversation = parseSessionFile(session.path);

      // Check if this is an incremental update
      const prevState = getSessionProcessingState(memory, session.sessionId);
      const isIncremental = prevState && prevState.messageCount < conversation.messages.length;

      if (isIncremental) {
        console.log(`üìñ Updating ${session.sessionId.slice(0, 8)}... (+${conversation.messages.length - prevState.messageCount} new messages)`);
      } else {
        console.log(`üìñ Processing ${session.sessionId.slice(0, 8)}... (${projectName.slice(-30)})`);
      }

      if (conversation.messages.length === 0) {
        console.log('   ‚ö†Ô∏è  No messages, skipping');
        continue;
      }

      if (options.dryRun) {
        console.log('   [dry-run] Would evolve fragments');
        continue;
      }

      // Window size for evolution - Gemini 2.5 Flash has 1M context, so we can go big
      const windowSize = 500;

      // For incremental updates, start from where we left off
      const startIndex = isIncremental ? prevState!.messageCount : 0;
      const messagesToProcess = conversation.messages.slice(startIndex);

      if (messagesToProcess.length === 0) {
        console.log('   ‚ö†Ô∏è  No new messages, skipping');
        continue;
      }

      const windows = [];
      for (let i = 0; i < messagesToProcess.length; i += windowSize) {
        windows.push(messagesToProcess.slice(i, i + windowSize));
      }

      // Rolling window: feed old fragments + new messages ‚Üí evolved fragments
      // For incremental: load previous session snapshot
      // For new session: start empty
      const existingSnapshot = memory.sessionSnapshots?.find(s => s.sessionId === session.sessionId);
      let currentFragments = existingSnapshot?.fragments || emptyFragments();
      let allSourceLinks: typeof conversation.messages[0]['source'][] = [];

      for (let i = 0; i < windows.length; i++) {
        const window = windows[i];

        if (options.verbose) {
          console.log(`   üîÑ Window ${i + 1}/${windows.length} (${window.length} messages)`);
        }

        const result = await evolveAllFragments(
          currentFragments,
          {
            messages: window,
            allFragments: currentFragments,
            project: conversation.project,
            sessionId: conversation.sessionId,
          },
          { apiKey }
        );

        if (result.errors.length > 0 && options.verbose) {
          for (const error of result.errors) {
            console.log(`   ‚ö†Ô∏è  ${error}`);
          }
        }

        currentFragments = result.fragments;
        allSourceLinks.push(...result.sourceLinks);
        totalTokens += result.tokensUsed;
      }

      // Update memory with message count for incremental tracking
      memory = updateProjectMemory(
        memory,
        currentFragments,
        session.sessionId,
        allSourceLinks,
        conversation.messages.length,
        session.modifiedTime
      );
      saveProjectMemory(memory);

      // Update index
      index.projects[projectName] = {
        lastUpdated: new Date().toISOString() as unknown as Date,
      } as any;

      processed++;
      console.log(`   ‚úÖ Evolved (${windows.length} windows, ${totalTokens} tokens total)`);
    }

    // Save index
    if (!options.dryRun) {
      saveMemoryIndex(index);
    }

    console.log('\nüìä Summary:');
    console.log(`   Found: ${sessions.length} sessions, ${sessionsNeedingWork.length} need updates`);
    console.log(`   Processed: ${processed} sessions`);
    console.log(`   Tokens used: ${totalTokens}`);

    // Run horizontal evolution if we processed any sessions
    if (processed > 0 && !options.dryRun) {
      console.log('\nüîÑ Running horizontal evolution...');

      // Get all unique projects that were processed
      const projectsProcessed = [...new Set(sessionsToProcess.map(s => s.project))];

      for (const projectName of projectsProcessed) {
        const memory = loadProjectMemory(projectName);
        if (!memory || !memory.sessionSnapshots?.length) continue;

        const result = await evolveHorizontal(
          memory.sessionSnapshots,
          { apiKey, windowSize: 5 }
        );

        const updated = updateCurrentFragments(memory, result.current);
        saveProjectMemory(updated);

        console.log(`   ${projectName.replace(/^-Users-[^-]+-src-/, '')}: ${result.sessionsIncluded} sessions ‚Üí current`);
        if (result.musings) {
          console.log(`   üí≠ ${result.musings.slice(0, 100)}...`);
        }
        totalTokens += result.tokensUsed;
      }
    }

    console.log(`   Total tokens: ${totalTokens}`);
    console.log(`   Memory stored: ${getMemoryDir()}`);
  });

// ============================================================================
// search - Semantic search through memory
// ============================================================================

program
  .command('search <query>')
  .alias('grep')
  .description('Semantic search through evolved memory')
  .option('-p, --project <name>', 'Filter to specific project (auto-detects from cwd if not specified)')
  .option('-a, --all', 'Search all projects (ignore cwd auto-detection)')
  .option('-t, --type <types>', 'Filter by type: decision,insight,gotcha,narrative,quote', 'decision,insight,gotcha')
  .option('-l, --limit <n>', 'Limit results', '10')
  .option('--json', 'Output as JSON')
  .action((query, options) => {
    const types = options.type.split(',') as any[];
    const limit = parseInt(options.limit, 10);

    // Auto-detect project from current directory unless --all is specified
    let projectFilter: string[] | undefined;
    if (options.project) {
      projectFilter = [options.project];
    } else if (!options.all) {
      // Try to match cwd to a project
      const cwd = process.cwd();
      const cwdSanitized = cwd.replace(/\//g, '-').replace(/^-/, '');
      const index = loadMemoryIndex();
      const matchingProject = Object.keys(index.projects).find(p =>
        p === cwdSanitized || p.endsWith(cwdSanitized) || cwdSanitized.endsWith(p.replace(/^-/, ''))
      );
      if (matchingProject) {
        projectFilter = [matchingProject];
        console.log(`üìÅ Searching in: ${matchingProject.replace(/^-Users-[^-]+-src-/, '')} (use --all for global search)\n`);
      }
    }

    const results = searchMemory(query, {
      projects: projectFilter,
      types,
      limit,
    });

    if (options.json) {
      console.log(JSON.stringify(results, null, 2));
      return;
    }

    if (results.length === 0) {
      console.log(`‚ùå No results found for "${query}"`);
      return;
    }

    console.log(`üîç Found ${results.length} results for "${query}":\n`);

    for (const result of results) {
      const typeIcon = {
        decision: '‚öñÔ∏è ',
        insight: 'üí°',
        gotcha: '‚ö†Ô∏è ',
        narrative: 'üìñ',
        quote: 'üí¨',
      }[result.type];

      const project = result.project.replace(/^-Users-[^-]+-src-/, '');
      const dateStr = result.timestamp
        ? new Date(result.timestamp).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })
        : '';
      console.log(`${typeIcon} [${result.type}] (${project}) ${dateStr}`);
      console.log(`   ${result.content}`);
      if (result.context) {
        console.log(`   ‚Üí ${result.context}`);
      }
      console.log('');
    }
  });

// ============================================================================
// status - Show memory statistics
// ============================================================================

program
  .command('status')
  .description('Show memory statistics (CWD-aware, use "status global" for all projects)')
  .argument('[scope]', '"global" for all projects, otherwise auto-detects from cwd')
  .action((scope) => {
    const isGlobal = scope === 'global';

    // Try to detect project from CWD
    let detectedProject: string | undefined;
    if (!isGlobal) {
      const cwd = process.cwd();
      const cwdSanitized = cwd.replace(/\//g, '-').replace(/^-/, '');
      const index = loadMemoryIndex();
      detectedProject = Object.keys(index.projects).find(p =>
        p === cwdSanitized || p.endsWith(cwdSanitized) || cwdSanitized.endsWith(p.replace(/^-/, ''))
      );

      // Also check raw session directories if not in evolved memory yet
      if (!detectedProject) {
        const sessions = discoverSessionFiles();
        const projectNames = [...new Set(sessions.map(s => s.project))];
        detectedProject = projectNames.find(p =>
          p === cwdSanitized || p.endsWith(cwdSanitized) || cwdSanitized.endsWith(p.replace(/^-/, ''))
        );
      }
    }

    if (detectedProject && !isGlobal) {
      // Project-specific status
      const shortName = detectedProject.replace(/^-Users-[^-]+-src-/, '');
      console.log(`üìä ${shortName}\n`);

      // Raw session files for this project
      const sessions = discoverSessionFiles(detectedProject);
      let totalMessages = 0;
      let earliestDate: Date | null = null;
      let latestDate: Date | null = null;

      for (const session of sessions) {
        const conversation = parseSessionFile(session.path);
        totalMessages += conversation.messages.length;

        if (!earliestDate || session.modifiedTime < earliestDate) {
          earliestDate = session.modifiedTime;
        }
        if (!latestDate || session.modifiedTime > latestDate) {
          latestDate = session.modifiedTime;
        }
      }

      console.log('üìÅ Raw Sessions:');
      console.log(`   Files: ${sessions.length}`);
      console.log(`   Messages: ${totalMessages.toLocaleString()}`);
      if (earliestDate && latestDate) {
        const fmt = (d: Date) => d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        console.log(`   Date range: ${fmt(earliestDate)} - ${fmt(latestDate)}`);
      }

      // Evolved memory for this project
      const memory = loadProjectMemory(detectedProject);
      if (memory) {
        const decisions = memory.current.decisions?.decisions?.length || 0;
        const insights = memory.current.insights?.insights?.length || 0;
        const gotchas = memory.current.insights?.gotchas?.length || 0;
        const processedCount = memory.processedSessions?.length || 0;

        console.log('\nüß† Evolved Memory:');
        console.log(`   Sessions: ${processedCount}/${sessions.length} processed`);
        console.log(`   Decisions: ${decisions}`);
        console.log(`   Insights: ${insights}`);
        console.log(`   Gotchas: ${gotchas}`);
        console.log(`   Last evolved: ${memory.lastUpdated.toLocaleString()}`);
      } else {
        console.log('\nüß† Evolved Memory:');
        console.log('   Not yet evolved. Run: claude-prose evolve');
      }

      console.log(`\nüí° Tip: Use "claude-prose status global" for all projects`);
    } else {
      // Global status (original behavior)
      const stats = getMemoryStats();
      const sessionStats = getSessionStats();

      console.log('üìä Claude Prose - Global Status\n');

      console.log('üìÅ Available Sessions:');
      console.log(`   Total sessions: ${sessionStats.totalSessions}`);
      console.log(`   Total messages: ${sessionStats.totalMessages.toLocaleString()}`);
      console.log(`   Projects: ${sessionStats.projects.length}`);
      if (sessionStats.dateRange.earliest && sessionStats.dateRange.latest) {
        console.log(`   Date range: ${sessionStats.dateRange.earliest.toLocaleDateString()} - ${sessionStats.dateRange.latest.toLocaleDateString()}`);
      }

      console.log('\nüß† Evolved Memory:');
      console.log(`   Projects: ${stats.totalProjects}`);
      console.log(`   Sessions processed: ${stats.totalSessions}`);
      console.log(`   Decisions captured: ${stats.totalDecisions}`);
      console.log(`   Insights captured: ${stats.totalInsights}`);
      if (stats.lastUpdated) {
        console.log(`   Last updated: ${stats.lastUpdated.toLocaleString()}`);
      }

      console.log(`\nüìÇ Memory location: ${getMemoryDir()}`);
    }
  });

// ============================================================================
// show - Display current fragments for a project
// ============================================================================

program
  .command('show <project>')
  .description('Display current fragments for a project')
  .option('--decisions', 'Show only decisions')
  .option('--insights', 'Show only insights')
  .option('--narrative', 'Show only narrative')
  .option('--json', 'Output as JSON')
  .action((project, options) => {
    // Try to match project by partial name
    const index = loadMemoryIndex();
    const projectNames = Object.keys(index.projects);

    const matchedProject = projectNames.find(p =>
      p.toLowerCase().includes(project.toLowerCase())
    );

    if (!matchedProject) {
      console.error(`‚ùå Project "${project}" not found`);
      console.log('Available projects:');
      for (const p of projectNames) {
        console.log(`  - ${p.replace(/^-Users-[^-]+-src-/, '')}`);
      }
      process.exit(1);
    }

    const memory = loadProjectMemory(matchedProject);
    if (!memory) {
      console.error(`‚ùå No memory found for project "${matchedProject}"`);
      process.exit(1);
    }

    if (options.json) {
      console.log(JSON.stringify(memory.current, null, 2));
      return;
    }

    const shortName = matchedProject.replace(/^-Users-[^-]+-src-/, '');
    console.log(`üß† Memory for: ${shortName}\n`);
    console.log(`   Sessions processed: ${memory.processedSessions.length}`);
    console.log(`   Last updated: ${memory.lastUpdated.toLocaleString()}\n`);

    const showAll = !options.decisions && !options.insights && !options.narrative;

    if (showAll || options.decisions) {
      console.log('‚öñÔ∏è  DECISIONS:');
      for (const decision of memory.current.decisions?.decisions || []) {
        console.log(`   ‚Ä¢ ${decision.what}`);
        console.log(`     Why: ${decision.why}`);
        console.log(`     Confidence: ${decision.confidence}`);
        console.log('');
      }
    }

    if (showAll || options.insights) {
      console.log('üí° INSIGHTS:');
      for (const insight of memory.current.insights?.insights || []) {
        console.log(`   ‚Ä¢ ${insight.learning}`);
        if (insight.context) {
          console.log(`     Context: ${insight.context}`);
        }
        console.log('');
      }

      if (memory.current.insights?.gotchas?.length) {
        console.log('‚ö†Ô∏è  GOTCHAS:');
        for (const gotcha of memory.current.insights.gotchas) {
          console.log(`   ‚Ä¢ ${gotcha.issue}`);
          if (gotcha.solution) {
            console.log(`     Solution: ${gotcha.solution}`);
          }
          console.log('');
        }
      }
    }

    if (showAll || options.narrative) {
      console.log('üìñ NARRATIVE:');
      for (const beat of memory.current.narrative?.story_beats || []) {
        const tone = beat.emotional_tone ? ` (${beat.emotional_tone})` : '';
        console.log(`   [${beat.beat_type}]${tone}: ${beat.summary}`);
      }
      console.log('');

      if (memory.current.narrative?.memorable_quotes?.length) {
        console.log('üí¨ QUOTES:');
        for (const quote of memory.current.narrative.memorable_quotes) {
          console.log(`   "${quote.quote}" - ${quote.speaker}`);
        }
      }
    }
  });

// ============================================================================
// context - Generate markdown for slash command injection
// ============================================================================

program
  .command('context <project>')
  .description('Generate context markdown for slash command injection')
  .option('-o, --output <path>', 'Output file path (default: stdout)')
  .option('--install', 'Install as Claude Code slash command in current project')
  .action((project, options) => {
    // Try to match project by partial name
    const index = loadMemoryIndex();
    const projectNames = Object.keys(index.projects);

    const matchedProject = projectNames.find(p =>
      p.toLowerCase().includes(project.toLowerCase())
    );

    if (!matchedProject) {
      console.error(`‚ùå Project "${project}" not found`);
      console.log('Available projects:');
      for (const p of projectNames) {
        console.log(`  - ${p.replace(/^-Users-[^-]+-src-/, '')}`);
      }
      process.exit(1);
    }

    const markdown = generateContextMarkdown(matchedProject);
    if (!markdown) {
      console.error(`‚ùå No memory found for project "${matchedProject}"`);
      process.exit(1);
    }

    if (options.install) {
      // Install as slash command in .claude/commands/
      const commandsDir = '.claude/commands';
      const commandPath = `${commandsDir}/memory.md`;

      writeContextFile(matchedProject, commandPath);
      console.log(`‚úÖ Installed as slash command: /memory`);
      console.log(`   File: ${commandPath}`);
      console.log('\n   Use in Claude Code: /memory');
    } else if (options.output) {
      writeContextFile(matchedProject, options.output);
      console.log(`‚úÖ Context written to: ${options.output}`);
    } else {
      // Output to stdout
      console.log(markdown);
    }
  });

// ============================================================================
// web - Generate browsable HTML website
// ============================================================================

program
  .command('web')
  .description('Generate a browsable HTML website from project memory')
  .option('-o, --output <dir>', 'Output directory', './claude-prose-web')
  .option('--open', 'Open in browser after generating')
  .action((options) => {
    console.log('üåê Generating Claude Prose website...\n');

    generateWebsite(options.output);

    if (options.open) {
      const indexPath = `${options.output}/index.html`;
      import('child_process').then(({ exec }) => {
        exec(`open "${indexPath}"`);
      });
    }
  });

// ============================================================================
// Parse and run
// ============================================================================

program.parse();
